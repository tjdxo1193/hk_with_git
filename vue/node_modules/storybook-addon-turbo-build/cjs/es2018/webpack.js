"use strict";
/**
 * @module
 * Helper functions for modifying webpack config.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceLoader = exports.removePlugin = exports.replaceMinimizer = exports.isRuleAppliedTo = void 0;
// https://webpack.js.org/configuration/module/#condition
function testRuleCondition(condition, filename) {
    if (typeof condition === "function") {
        return condition(filename);
    }
    if (typeof condition === "string") {
        return condition.indexOf(filename) === 0;
    }
    if (condition instanceof RegExp) {
        return condition.test(filename);
    }
    if (condition instanceof Array) {
        return condition.some((child) => testRuleCondition(child, filename));
    }
    // Object-style condition is not supported.
    return false;
}
/**
 * Returns whether the rule will be applied to a file with given filename.
 * @param rule rule to test
 * @param filename filename or filepath to test with
 * @returns whether the rule is active for the file
 */
function isRuleAppliedTo(rule, filename) {
    if (!rule.test) {
        return false;
    }
    return testRuleCondition(rule.test, filename);
}
exports.isRuleAppliedTo = isRuleAppliedTo;
/**
 * Replace minimizer library.
 * @param config webpack config
 * @param minimizer new minimizer
 * @returns modified webpack config
 */
function replaceMinimizer(config, minimizer) {
    var _a;
    return {
        ...config,
        optimization: {
            // Use provided optimization configuration other than minimizer
            ...((_a = config.optimization) !== null && _a !== void 0 ? _a : {
                // In case where config.optimization is empty (probably never happen)
                minimize: true,
            }),
            minimizer: [minimizer],
        },
    };
}
exports.replaceMinimizer = replaceMinimizer;
/**
 * Remove a plugin from a plugin list in a given webpack config.
 * @param config webpack config
 * @param ctor constructor of the plugin to remove
 * @returns modified webpack config
 */
function removePlugin(config, ctor) {
    if (!config.plugins || !config.plugins.length) {
        return config;
    }
    return {
        ...config,
        plugins: config.plugins.filter((plugin) => !(plugin instanceof ctor)),
    };
}
exports.removePlugin = removePlugin;
/**
 * Replace or Remove loader matching to `test` with a value returned from `replaceWith`.
 * @param config webpack config
 * @param test decides whether the loader is replaced (removed). think as 1st parameter of Array.prototype.filter
 * @param replaceWith a factory function returns a rule which takes place in. return null to remove the loader
 * @returns modified webpack config
 */
function replaceLoader(config, test, replaceWith) {
    var _a;
    if (!((_a = config.module) === null || _a === void 0 ? void 0 : _a.rules)) {
        return config;
    }
    return {
        ...config,
        module: {
            ...config.module,
            rules: replaceLoaderInternal(config.module.rules, test, replaceWith),
        },
    };
}
exports.replaceLoader = replaceLoader;
function replaceLoaderInternal(rules, test, replaceWith) {
    if (!rules) {
        return rules;
    }
    const replaceRuleSetUse = (use, rule) => {
        var _a;
        // NOTE: Function Use needs compiler information to call.
        if (typeof use === "function") {
            return use;
        }
        if (use instanceof Array) {
            const transformed = use
                .map((item) => {
                if (test(item, rule)) {
                    return replaceWith(item, rule);
                }
                return item;
            })
                .filter((item) => !!item);
            switch (transformed.length) {
                case 0:
                    return undefined;
                case 1:
                    return transformed[0];
                default:
                    return transformed;
            }
        }
        return test(use, rule) ? (_a = replaceWith(use, rule)) !== null && _a !== void 0 ? _a : undefined : use;
    };
    return rules.map((rule) => {
        if (rule.oneOf) {
            return {
                ...rule,
                oneOf: replaceLoaderInternal(rule.oneOf, test, replaceWith),
            };
        }
        if (rule.loader) {
            return {
                ...rule,
                loader: replaceRuleSetUse(rule.loader, rule),
            };
        }
        if (rule.loaders) {
            return {
                ...rule,
                loaders: replaceRuleSetUse(rule.loaders, rule),
            };
        }
        if (rule.use) {
            return {
                ...rule,
                use: replaceRuleSetUse(rule.use, rule),
            };
        }
        return rule;
    });
}
